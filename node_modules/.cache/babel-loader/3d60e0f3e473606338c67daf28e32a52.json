{"ast":null,"code":"import InlineWorker from 'inline-worker';\nexport class Recorder {\n  constructor(source, cfg) {\n    this.config = {\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav',\n      ...cfg\n    };\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n\n    this.node.onaudioprocess = e => {\n      if (!this.recording) return;\n      var buffer = [];\n\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n\n      this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    let self = {};\n    this.worker = new InlineWorker(function () {\n      let recLength = 0,\n          recBuffers = [],\n          sampleRate,\n          numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n\n          case 'record':\n            record(e.data.buffer);\n            break;\n\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n\n          case 'getBuffer':\n            getBuffer();\n            break;\n\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      let newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        let buffers = [];\n\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        let interleaved;\n\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        } // converts sample rate to 48000 if higher than 48000\n\n\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n        let dataview = encodeWAV(downSampledBuffer);\n        let audioBlob = new Blob([dataview], {\n          type: type\n        });\n        this.postMessage({\n          command: 'exportWAV',\n          data: audioBlob\n        });\n      }\n\n      function getBuffer() {\n        let buffers = [];\n\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        this.postMessage({\n          command: 'getBuffer',\n          data: buffers\n        });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (let channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        let result = new Float32Array(recLength);\n        let offset = 0;\n\n        for (let i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        let length = inputL.length + inputR.length;\n        let result = new Float32Array(length);\n        let index = 0,\n            inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (let i = 0; i < input.length; i++, offset += 2) {\n          let s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      } // Down sample buffer before WAV encoding\n\n\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio); // Use average value of skipped samples\n\n          var accum = 0,\n              count = 0;\n\n          for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n          }\n\n          result[offsetResult] = accum / count; // Or you can simply get rid of the skipped samples:\n          // result[offsetResult] = buffer[nextOffsetBuffer];\n\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\n        let view = new DataView(buffer);\n        /* RIFF identifier */\n\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n\n        view.setUint16(20, 1, true);\n        /* channel count */\n\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n\n        view.setUint32(24, newSampleRate, true);\n        /* byte rate (sample rate * block align) */\n\n        view.setUint32(28, newSampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n\n        writeString(view, 36, 'data');\n        /* data chunk length */\n\n        view.setUint32(40, samples.length * 2, true);\n        floatTo16BitPCM(view, 44, samples);\n        return view;\n      }\n    }, self);\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = e => {\n      let cb = this.callbacks[e.data.command].pop();\n\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  record() {\n    this.recording = true;\n  }\n\n  stop() {\n    this.recording = false;\n  }\n\n  clear() {\n    this.worker.postMessage({\n      command: 'clear'\n    });\n  }\n\n  getBuffer(cb) {\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n    this.callbacks.getBuffer.push(cb);\n    this.worker.postMessage({\n      command: 'getBuffer'\n    });\n  }\n\n  exportWAV(cb, mimeType) {\n    mimeType = mimeType || this.config.mimeType;\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n    this.callbacks.exportWAV.push(cb);\n    this.worker.postMessage({\n      command: 'exportWAV',\n      type: mimeType\n    });\n  }\n\n  static forceDownload(blob, filename) {\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\n    let link = window.document.createElement('a');\n    link.href = url;\n    link.download = filename || 'output.wav';\n    let click = document.createEvent('Event');\n    click.initEvent('click', true, true);\n    link.dispatchEvent(click);\n  }\n\n}\nexport default Recorder;","map":{"version":3,"sources":["/Users/rodolfopavez/Desktop/ideaufro/frontend/src/Hooks/recorder.js"],"names":["InlineWorker","Recorder","constructor","source","cfg","config","bufferLen","numChannels","mimeType","recording","callbacks","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","call","onaudioprocess","e","buffer","channel","push","inputBuffer","getChannelData","worker","postMessage","command","connect","destination","self","recLength","recBuffers","sampleRate","onmessage","data","init","record","type","clear","newSampleRate","initBuffers","length","buffers","mergeBuffers","interleaved","interleave","downSampledBuffer","downSampleBuffer","dataview","encodeWAV","audioBlob","Blob","result","Float32Array","offset","i","set","inputL","inputR","index","inputIndex","floatTo16BitPCM","output","input","s","Math","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","samples","ArrayBuffer","DataView","setUint32","setUint16","cb","pop","stop","callback","Error","forceDownload","blob","filename","url","window","URL","webkitURL","createObjectURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent"],"mappings":"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","sourcesContent":["import InlineWorker from 'inline-worker';\n\nexport class Recorder {\n  constructor(source, cfg) {\n    this.config = {\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav',\n      ...cfg\n    };\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\n    ).call(\n      this.context,\n      this.config.bufferLen,\n      this.config.numChannels,\n      this.config.numChannels\n    );\n\n    this.node.onaudioprocess = (e) => {\n      if (!this.recording) return;\n\n      var buffer = [];\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n      this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    let self = {};\n    this.worker = new InlineWorker(function () {\n      let recLength = 0,\n        recBuffers = [],\n        sampleRate,\n        numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n          case 'record':\n            record(e.data.buffer);\n            break;\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n          case 'getBuffer':\n            getBuffer();\n            break;\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      let newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        let interleaved;\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        // converts sample rate to 48000 if higher than 48000\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n\n        let dataview = encodeWAV(downSampledBuffer);\n        let audioBlob = new Blob([dataview], { type: type });\n\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\n      }\n\n      function getBuffer() {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        this.postMessage({ command: 'getBuffer', data: buffers });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (let channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        let result = new Float32Array(recLength);\n        let offset = 0;\n        for (let i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        let length = inputL.length + inputR.length;\n        let result = new Float32Array(length);\n\n        let index = 0,\n          inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (let i = 0; i < input.length; i++, offset += 2) {\n          let s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      // Down sample buffer before WAV encoding\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round(\n            (offsetResult + 1) * sampleRateRatio\n          );\n          // Use average value of skipped samples\n          var accum = 0,\n            count = 0;\n          for (\n            var i = offsetBuffer;\n            i < nextOffsetBuffer && i < buffer.length;\n            i++\n          ) {\n            accum += buffer[i];\n            count++;\n          }\n          result[offsetResult] = accum / count;\n          // Or you can simply get rid of the skipped samples:\n          // result[offsetResult] = buffer[nextOffsetBuffer];\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\n        let view = new DataView(buffer);\n\n        /* RIFF identifier */\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n        view.setUint16(20, 1, true);\n        /* channel count */\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n        view.setUint32(24, newSampleRate, true);\n        /* byte rate (sample rate * block align) */\n        view.setUint32(28, newSampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n        writeString(view, 36, 'data');\n        /* data chunk length */\n        view.setUint32(40, samples.length * 2, true);\n\n        floatTo16BitPCM(view, 44, samples);\n\n        return view;\n      }\n    }, self);\n\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = (e) => {\n      let cb = this.callbacks[e.data.command].pop();\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  record() {\n    this.recording = true;\n  }\n\n  stop() {\n    this.recording = false;\n  }\n\n  clear() {\n    this.worker.postMessage({ command: 'clear' });\n  }\n\n  getBuffer(cb) {\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.getBuffer.push(cb);\n\n    this.worker.postMessage({ command: 'getBuffer' });\n  }\n\n  exportWAV(cb, mimeType) {\n    mimeType = mimeType || this.config.mimeType;\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.exportWAV.push(cb);\n\n    this.worker.postMessage({\n      command: 'exportWAV',\n      type: mimeType\n    });\n  }\n\n  static forceDownload(blob, filename) {\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\n    let link = window.document.createElement('a');\n    link.href = url;\n    link.download = filename || 'output.wav';\n    let click = document.createEvent('Event');\n    click.initEvent('click', true, true);\n    link.dispatchEvent(click);\n  }\n}\n\nexport default Recorder;\n"]},"metadata":{},"sourceType":"module"}